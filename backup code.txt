# 버전: 1.0.0
# 작성자: Levi Beak
# 최종 수정일: 2025-02-04

import pandas as pd
import glob
import os
import sqlite3
import tkinter as tk
from tkinter import filedialog, ttk, messagebox, simpledialog
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from datetime import datetime
import sys

class DBManager:
    def __init__(self):
        self.window = tk.Tk()
        self.window.title("DB 관리 프로그램")
        self.window.geometry("1300x800")
        
        # 실행 파일과 개발 환경 모두에서 작동하도록 경로 처리
        try:
            if getattr(sys, 'frozen', False):
                # 실행 파일로 실행될 때의 경로
                application_path = sys._MEIPASS
            else:
                # 일반 Python 스크립트로 실행될 때의 경로
                application_path = os.path.dirname(os.path.abspath(__file__))
            
            icon_path = os.path.join(application_path, "resources", "icons", "db_compare.ico")
            self.window.iconbitmap(icon_path)
        except Exception as e:
            print(f"아이콘 로드 실패: {str(e)}")
        
        # Maintenance Mode 상태 변수
        self.maint_mode = False
        self.default_password = "1234"  # 실제 배포시에는 더 안전한 방식으로 관리
        
        # 메뉴바 생성
        self.create_menu()
        
        # 단축키 바인딩
        self.window.bind('<F1>', lambda event: self.show_user_guide())
        self.window.bind('<Control-o>', lambda event: self.load_folder())
        self.window.bind('<Control-O>', lambda event: self.load_folder())
        
        # 상태 표시줄 생성
        self.status_bar = ttk.Label(self.window, relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # 기본 UI 구성
        self.main_notebook = ttk.Notebook(self.window)
        self.main_notebook.pack(expand=True, fill=tk.BOTH)
        
        # 비교 노트북 생성
        self.comparison_notebook = ttk.Notebook(self.main_notebook)
        self.main_notebook.add(self.comparison_notebook, text="DB 비교")
        
        # 초기 상태 설정
        self.file_names = []
        self.folder_path = ""
        self.merged_df = None
        
        # DB 비교 관련 탭 생성
        self.create_comparison_tabs()

    def create_menu(self):
        menubar = tk.Menu(self.window)
        self.window.config(menu=menubar)
        
        # 파일 메뉴
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="파일", menu=file_menu)
        file_menu.add_command(label="폴더 열기 (Ctrl+O)", command=self.load_folder)
        file_menu.add_separator()
        file_menu.add_command(label="종료", command=self.window.quit)
        
        # 도움말 메뉴
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="도움말", menu=help_menu)
        help_menu.add_command(label="사용 설명서 (F1)", command=self.show_user_guide)
        help_menu.add_separator()
        help_menu.add_command(label="프로그램 정보", command=self.show_about)

    def toggle_maint_mode(self):
        # 비밀번호 입력 창
        password = simpledialog.askstring("Maintenance Mode", 
                                        "비밀번호를 입력하세요:",
                                        show='*')
        
        if password == self.default_password:
            self.maint_mode = not self.maint_mode
            if self.maint_mode:
                self.enable_maint_features()
                messagebox.showinfo("알림", "Maintenance Mode가 활성화되었습니다.")
            else:
                self.disable_maint_features()
                messagebox.showinfo("알림", "Maintenance Mode가 비활성화되었습니다.")
        else:
            messagebox.showerror("오류", "잘못된 비밀번호입니다.")

    def enable_maint_features(self):
        # QC 검수 탭 추가
        self.create_qc_tab()
        
    def disable_maint_features(self):
        # QC 검수 탭 제거
        for tab in self.main_notebook.tabs():
            tab_text = self.main_notebook.tab(tab, "text")
            if tab_text == "QC 검수":
                self.main_notebook.forget(tab)

    def create_qc_tab(self):
        # QC 검수 탭이 없을 때만 생성
        if not any(self.main_notebook.tab(tab, "text") == "QC 검수" 
                  for tab in self.main_notebook.tabs()):
            qc_tab = ttk.Frame(self.main_notebook)
            self.main_notebook.add(qc_tab, text="QC 검수")
            
            # QC 검수 탭 내용 구성
            qc_label = ttk.Label(qc_tab, text="QC 검수 기능 - 개발 중")
            qc_label.pack(pady=20)

    def create_comparison_tabs(self):
        """비교 관련 탭 생성"""
        # 격자 뷰 탭 생성
        self.create_grid_view_tab()
        # DB 값 비교 탭 생성
        self.create_comparison_tab()
        # 다른 값만 보기 탭 생성
        self.create_diff_only_tab()
        # 보고서 탭 생성
        self.create_report_tab()

    def load_folder(self):
        # 파일 확장자 필터 설정
        filetypes = [
            ("DB 파일", "*.txt;*.db;*.csv"),
            ("텍스트 파일", "*.txt"),
            ("CSV 파일", "*.csv"),
            ("DB 파일", "*.db"),
            ("모든 파일", "*.*")
        ]
        
        # 파일 선택 다이얼로그
        files = filedialog.askopenfilenames(
            title="📂 DB 파일을 선택하세요",
            filetypes=filetypes,
            initialdir=self.folder_path if self.folder_path else None
        )
        
        if not files:
            self.status_bar.config(text="파일 선택이 취소되었습니다.")
            return

        # 로딩 다이얼로그 생성
        loading_dialog = LoadingDialog(self.window)
        
        try:
            df_list = []
            self.file_names = []
            total_files = len(files)
            
            # 초기 진행률 표시
            loading_dialog.update_progress(0, "파일 로딩 준비 중...")
            
            for idx, file in enumerate(files, 1):
                try:
                    # 파일 로딩 진행률 (0-70%)
                    progress = (idx / total_files) * 70
                    loading_dialog.update_progress(
                        progress,
                        f"파일 로딩 중... ({idx}/{total_files})"
                    )
                    
                    file_name = os.path.basename(file)
                    base_name = os.path.splitext(file_name)[0]
                    ext = os.path.splitext(file_name)[1].lower()
                    
                    # 파일 형식에 따른 로드
                    if ext == '.txt':
                        df = pd.read_csv(file, delimiter="\t", dtype=str)
                    elif ext == '.csv':
                        df = pd.read_csv(file, dtype=str)
                    elif ext == '.db':
                        conn = sqlite3.connect(file)
                        df = pd.read_sql("SELECT * FROM main_table", conn)
                        conn.close()
                    
                    df["Model"] = base_name
                    df_list.append(df)
                    self.file_names.append(base_name)
                    
                except Exception as e:
                    messagebox.showwarning(
                        "경고", 
                        f"'{file_name}' 파일 로드 중 오류 발생:\n{str(e)}"
                    )
            
            if df_list:
                # 선택된 파일들의 폴더 경로 저장
                self.folder_path = os.path.dirname(files[0])
                
                # 데이터프레임 병합
                loading_dialog.update_progress(75, "데이터 병합 중...")
                self.merged_df = pd.concat(df_list, ignore_index=True)
                
                # UI 업데이트
                loading_dialog.update_progress(85, "화면 업데이트 중...")
                self.update_all_tabs()
                
                loading_dialog.update_progress(100, "완료!")
                
                # 완료 메시지
                loading_dialog.close()
                messagebox.showinfo(
                    "로드 완료",
                    f"총 {len(df_list)}개의 DB 파일을 성공적으로 로드했습니다.\n"
                    f"• 폴더: {self.folder_path}\n"
                    f"• 파일: {', '.join(self.file_names)}"
                )
                
                # 상태 표시줄 업데이트
                self.status_bar.config(
                    text=f"총 {len(df_list)}개의 DB 파일이 로드되었습니다. "
                         f"(폴더: {os.path.basename(self.folder_path)})"
                )
            else:
                loading_dialog.close()
                messagebox.showerror("오류", "파일을 로드할 수 없습니다.")
                self.status_bar.config(text="파일 로드 실패")
                
        except Exception as e:
            loading_dialog.close()
            messagebox.showerror("오류", f"예기치 않은 오류가 발생했습니다:\n{str(e)}")

    def update_all_tabs(self):
        # 기존 탭 제거
        for tab in self.comparison_notebook.winfo_children():
            tab.destroy()
        
        # 탭 다시 생성
        self.create_comparison_tabs()

    def create_grid_view_tab(self):
        grid_frame = ttk.Frame(self.comparison_notebook)
        self.comparison_notebook.add(grid_frame, text="📑 격자 뷰")
        
        grid_frame.rowconfigure([0, 1, 2], weight=1)
        grid_frame.columnconfigure([0, 1], weight=1)
        
        max_columns = 2
        for idx, file_name in enumerate(self.file_names[:6]):
            row = idx // max_columns
            col = idx % max_columns
            
            frame = ttk.LabelFrame(grid_frame, text=f"📌 {file_name}")
            frame.grid(row=row, column=col, padx=5, pady=5, sticky="nsew")
            frame.rowconfigure(0, weight=1)
            frame.columnconfigure(0, weight=1)
            
            container = ttk.Frame(frame)
            container.pack(fill=tk.BOTH, expand=True)
            
            # 트리뷰 추가
            tree = ttk.Treeview(container)
            tree["columns"] = ("Module", "Part", "ItemName", "ItemValue")
            tree.heading("#0", text="구조", anchor="w")
            tree.heading("Module", text="Module", anchor="w")
            tree.heading("Part", text="Part", anchor="w")
            tree.heading("ItemName", text="Item Name", anchor="w")
            tree.heading("ItemValue", text="Item Value", anchor="w")
            
            # 스크롤바 추가
            v_scroll = ttk.Scrollbar(container, orient="vertical", command=tree.yview)
            h_scroll = ttk.Scrollbar(container, orient="horizontal", command=tree.xview)
            tree.configure(yscroll=v_scroll.set, xscroll=h_scroll.set)
            
            v_scroll.pack(side=tk.RIGHT, fill=tk.Y)
            h_scroll.pack(side=tk.BOTTOM, fill=tk.X)
            tree.pack(expand=True, fill=tk.BOTH)
            
            # 데이터 추가
            if self.merged_df is not None:
                model_data = self.merged_df[self.merged_df["Model"] == file_name]
                for module in model_data["Module"].unique():
                    module_node = tree.insert("", "end", text=f"📁 {module}", open=False)
                    
                    module_data = model_data[model_data["Module"] == module]
                    for part in module_data["Part"].unique():
                        part_node = tree.insert(module_node, "end", text=f"📂 {part}", open=False)
                        
                        part_data = module_data[model_data["Part"] == part]
                        for _, row in part_data.iterrows():
                            item_name = row["ItemName"]
                            item_value = row["ItemValue"]
                            tree.insert(part_node, "end", text=item_name, 
                                      values=(module, part, item_name, item_value))

    def create_comparison_tab(self):
        comparison_frame = ttk.Frame(self.comparison_notebook)
        self.comparison_notebook.add(comparison_frame, text="DB 값 비교")
        
        # 트리뷰 생성
        self.comparison_tree = ttk.Treeview(comparison_frame)
        self.comparison_tree["columns"] = ["Module", "Part", "ItemName"] + self.file_names
        
        # 컬럼 설정
        self.comparison_tree.heading("#0", text="", anchor="w")
        self.comparison_tree.column("#0", width=0, stretch=False)
        
        for col in ["Module", "Part", "ItemName"]:
            self.comparison_tree.heading(col, text=col, anchor="w")
            self.comparison_tree.column(col, width=100)
        
        for model in self.file_names:
            self.comparison_tree.heading(model, text=model, anchor="w")
            self.comparison_tree.column(model, width=150)
        
        # 스크롤바 추가
        v_scroll = ttk.Scrollbar(comparison_frame, orient="vertical", 
                                command=self.comparison_tree.yview)
        h_scroll = ttk.Scrollbar(comparison_frame, orient="horizontal", 
                                command=self.comparison_tree.xview)
        self.comparison_tree.configure(yscroll=v_scroll.set, xscroll=h_scroll.set)
        
        # 레이아웃
        v_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        h_scroll.pack(side=tk.BOTTOM, fill=tk.X)
        self.comparison_tree.pack(expand=True, fill=tk.BOTH)
        
        # 데이터 표시
        self.update_comparison_view()

    def update_comparison_view(self):
        # 기존 항목 삭제
        for item in self.comparison_tree.get_children():
            self.comparison_tree.delete(item)
        
        if self.merged_df is not None:
            # 데이터 비교 및 표시
            grouped = self.merged_df.groupby(["Module", "Part", "ItemName"])
            
            for (module, part, item_name), group in grouped:
                values = [module, part, item_name]
                
                # 각 모델의 값 추가
                for model in self.file_names:
                    model_value = group[group["Model"] == model]["ItemValue"].values
                    value = model_value[0] if len(model_value) > 0 else "-"
                    values.append(value)
                
                # 값이 다른 항목은 태그 추가
                model_values = values[3:]
                tags = ("different",) if len(set(model_values)) > 1 else ()
                
                # 모든 항목 표시
                self.comparison_tree.insert("", "end", values=values, tags=tags)
            
            # 다른 값을 가진 행 하이라이트
            self.comparison_tree.tag_configure("different", background="light yellow")

    def create_diff_only_tab(self):
        # 다른 값만 보기 탭 생성
        diff_frame = ttk.Frame(self.comparison_notebook)
        self.comparison_notebook.add(diff_frame, text="다른 값만 보기")
        
        # 트리뷰 생성
        self.diff_tree = ttk.Treeview(diff_frame)
        self.diff_tree["columns"] = ["Module", "Part", "ItemName"] + self.file_names
        
        # 컬럼 설정
        self.diff_tree.heading("#0", text="", anchor="w")
        self.diff_tree.column("#0", width=0, stretch=False)
        
        for col in ["Module", "Part", "ItemName"]:
            self.diff_tree.heading(col, text=col, anchor="w")
            self.diff_tree.column(col, width=100)
        
        for model in self.file_names:
            self.diff_tree.heading(model, text=model, anchor="w")
            self.diff_tree.column(model, width=150)
        
        # 스크롤바 추가
        v_scroll = ttk.Scrollbar(diff_frame, orient="vertical", command=self.diff_tree.yview)
        h_scroll = ttk.Scrollbar(diff_frame, orient="horizontal", command=self.diff_tree.xview)
        self.diff_tree.configure(yscroll=v_scroll.set, xscroll=h_scroll.set)
        
        # 레이아웃
        v_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        h_scroll.pack(side=tk.BOTTOM, fill=tk.X)
        self.diff_tree.pack(expand=True, fill=tk.BOTH)
        
        # 데이터 표시
        self.update_diff_view()

    def update_diff_view(self):
        # 기존 항목 삭제
        for item in self.diff_tree.get_children():
            self.diff_tree.delete(item)
        
        if self.merged_df is not None:
            # 데이터 비교 및 표시
            grouped = self.merged_df.groupby(["Module", "Part", "ItemName"])
            
            for (module, part, item_name), group in grouped:
                values = [module, part, item_name]
                
                # 각 모델의 값 추가
                model_values = []
                for model in self.file_names:
                    model_value = group[group["Model"] == model]["ItemValue"].values
                    value = model_value[0] if len(model_value) > 0 else "-"
                    values.append(value)
                    model_values.append(value)
                
                # 값이 다른 항목만 표시
                if len(set(model_values)) > 1:
                    self.diff_tree.insert("", "end", values=values, tags=("different",))
        
            # 다른 값을 가진 행 하이라이트
            self.diff_tree.tag_configure("different", background="light yellow")

    def create_report_tab(self):
        # 보고서 탭 생성
        report_frame = ttk.Frame(self.comparison_notebook)
        self.comparison_notebook.add(report_frame, text="📊 비교 보고서")
        
        # 통계 프레임과 차트 프레임을 나란히 배치
        stats_frame = ttk.LabelFrame(report_frame, text="📈 비교 통계")
        stats_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        chart_frame = ttk.LabelFrame(report_frame, text="📊 시각화")
        chart_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        if self.merged_df is not None:
            # 통계 정보 계산
            stats = self.calculate_stats()
            
            # 전체 통계
            total_frame = ttk.LabelFrame(stats_frame, text="전체 통계")
            total_frame.pack(fill=tk.X, padx=5, pady=5)
            ttk.Label(total_frame, 
                     text=f"총 {stats['total_diff']}개 항목에서 차이가 발견되었습니다.",
                     font=('Arial', 10, 'bold')).pack(pady=5)
            
            # 모듈별 통계
            module_frame = ttk.LabelFrame(stats_frame, text="모듈별 차이")
            module_frame.pack(fill=tk.X, padx=5, pady=5)
            
            # 모듈별 트리뷰
            module_tree = ttk.Treeview(module_frame, height=10)
            module_tree["columns"] = ["count"]
            module_tree.heading("#0", text="모듈", anchor="w")
            module_tree.heading("count", text="차이 개수", anchor="w")
            module_tree.column("#0", width=200)
            module_tree.column("count", width=100)
            
            for module, count in sorted(stats['module_diff'].items(), key=lambda x: x[1], reverse=True):
                module_tree.insert("", "end", text=module, values=(count,))
            
            module_tree.pack(fill=tk.X, padx=5, pady=5)
            
            # 파트별 통계
            part_frame = ttk.LabelFrame(stats_frame, text="상세 경로별 차이")
            part_frame.pack(fill=tk.X, padx=5, pady=5)
            
            # 파트별 트리뷰
            part_tree = ttk.Treeview(part_frame, height=15)
            part_tree["columns"] = ["count"]
            part_tree.heading("#0", text="경로", anchor="w")
            part_tree.heading("count", text="차이 개수", anchor="w")
            part_tree.column("#0", width=200)
            part_tree.column("count", width=100)
            
            for part, count in sorted(stats['part_diff'].items(), key=lambda x: x[1], reverse=True):
                part_tree.insert("", "end", text=part, values=(count,))
            
            part_tree.pack(fill=tk.X, padx=5, pady=5)
            
            # 차트 생성
            try:
                # 한글 폰트 설정
                plt.rcParams['font.family'] = 'Malgun Gothic'
                
                # 그래프 생성
                fig = plt.figure(figsize=(8, 10))
                
                # 모듈별 차이 그래프
                ax1 = fig.add_subplot(211)
                modules = list(stats['module_diff'].keys())
                counts = list(stats['module_diff'].values())
                bars1 = ax1.bar(range(len(modules)), counts)
                ax1.set_title('Module Differences')
                ax1.set_xticks(range(len(modules)))
                ax1.set_xticklabels(modules, rotation=45, ha='right')
                
                # 막대 위에 값 표시
                for bar in bars1:
                    height = bar.get_height()
                    ax1.text(bar.get_x() + bar.get_width()/2., height,
                            f'{int(height)}',
                            ha='center', va='bottom')
                
                # 파트별 차이 그래프 (상위 10개만)
                ax2 = fig.add_subplot(212)
                parts = list(stats['part_diff'].keys())[:10]
                part_counts = list(stats['part_diff'].values())[:10]
                bars2 = ax2.bar(range(len(parts)), part_counts)
                ax2.set_title('Top 10 Path Differences')
                ax2.set_xticks(range(len(parts)))
                ax2.set_xticklabels(parts, rotation=45, ha='right')
                
                # 막대 위에 값 표시
                for bar in bars2:
                    height = bar.get_height()
                    ax2.text(bar.get_x() + bar.get_width()/2., height,
                            f'{int(height)}',
                            ha='center', va='bottom')
                
                plt.tight_layout()
                
                # 캔버스에 그래프 표시
                canvas = FigureCanvasTkAgg(fig, master=chart_frame)
                canvas.draw()
                canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
                
            except Exception as e:
                error_msg = f"차트 생성 중 오류가 발생했습니다: {str(e)}"
                ttk.Label(chart_frame, text=error_msg, wraplength=300).pack(pady=20)
                print(error_msg)

    def calculate_stats(self):
        stats = {}
        grouped = self.merged_df.groupby(["Module", "Part", "ItemName"])
        
        # 모듈별 차이 개수
        module_diff = {}
        # 파트별 차이 개수
        part_diff = {}
        # 전체 차이 개수
        total_diff = 0
        
        for (module, part, item_name), group in grouped:
            values = [group[group["Model"] == model]["ItemValue"].values[0] 
                     if len(group[group["Model"] == model]["ItemValue"]) > 0 
                     else "-" for model in self.file_names]
            
            if len(set(values)) > 1:  # 값이 다른 경우
                total_diff += 1
                module_diff[module] = module_diff.get(module, 0) + 1
                part_key = f"{module} > {part}"
                part_diff[part_key] = part_diff.get(part_key, 0) + 1
        
        return {
            'total_diff': total_diff,
            'module_diff': module_diff,
            'part_diff': part_diff
        }

    def create_about_tab(self):
        # About 탭 생성
        self.about_frame = ttk.Frame(self.main_notebook)
        self.main_notebook.add(self.about_frame, text="About")
        
        # 스타일 설정
        style = ttk.Style()
        style.configure("Title.TLabel", font=('Helvetica', 16, 'bold'))
        style.configure("Header.TLabel", font=('Helvetica', 12, 'bold'))
        style.configure("Content.TLabel", font=('Helvetica', 10))
        
        # 컨테이너 프레임
        container = ttk.Frame(self.about_frame, padding="20")
        container.pack(expand=True, fill=tk.BOTH)
        
        # 프로그램 제목
        title_frame = ttk.Frame(container)
        title_frame.pack(fill=tk.X, pady=(0, 20))
        ttk.Label(title_frame, text="DB 관리 프로그램", style="Title.TLabel").pack()
        
        # 정보 섹션들
        sections = [
            ("Product Information", [
                ("Version", "1.0.0"),
                ("Release Date", "2025-02-04"),
            ]),
            ("Development", [
                ("Developer", "Levi Beak / 백광림"),
                ("Organization", "Quality Assurance Team"),
                ("Contact", "levi.beak@parksystems.com"),
            ]),
                        ]
        
        for section_title, items in sections:
            # 섹션 프레임
            section_frame = ttk.LabelFrame(container, text=section_title, padding="10")
            section_frame.pack(fill=tk.X, pady=(0, 10))
            
            # 그리드 구성
            for i, (key, value) in enumerate(items):
                ttk.Label(section_frame, text=key + ":", style="Header.TLabel").grid(
                    row=i, column=0, sticky="w", padx=(0, 10), pady=2)
                ttk.Label(section_frame, text=value, style="Content.TLabel").grid(
                    row=i, column=1, sticky="w", pady=2)
        
        # 프로그램 설명
        desc_frame = ttk.LabelFrame(container, text="Description", padding="10")
        desc_frame.pack(fill=tk.X, pady=(0, 10))
        
        description = """이 프로그램은 XES 데이터베이스 비교 및 관리를 위한 프로그램입니다.
        
주요 기능:
• 다중 DB 파일 비교 분석
• 차이점 자동 감지 및 하이라이트
• 상세 비교 보고서 생성
• 데이터 시각화 및 통계 분석
• QC 스펙 관리 및 검증(추가 예정)
"""
        
        ttk.Label(desc_frame, text=description, style="Content.TLabel", 
                 wraplength=500, justify="left").pack(anchor="w")

    def show_about(self):
        # About 창 생성
        about_window = tk.Toplevel(self.window)
        about_window.title("About")
        about_window.geometry("600x800")
        
        # 스타일 설정
        style = ttk.Style()
        style.configure("Title.TLabel", font=('Helvetica', 16, 'bold'))
        style.configure("Header.TLabel", font=('Helvetica', 12, 'bold'))
        style.configure("Content.TLabel", font=('Helvetica', 10))
        
        # 컨테이너 프레임
        container = ttk.Frame(about_window, padding="20")
        container.pack(expand=True, fill=tk.BOTH)
        
        # 프로그램 제목
        title_frame = ttk.Frame(container)
        title_frame.pack(fill=tk.X, pady=(0, 20))
        ttk.Label(title_frame, text="DB 관리 프로그램", style="Title.TLabel").pack()
        
        # 정보 섹션들
        sections = [
            ("Product Information", [
                ("Version", "1.0.0"),
                ("Release Date", "2025-02-04"),
            ]),
            ("Development", [
                ("Developer", "Levi Beak / 백광림"),
                ("Organization", "Quality Assurance Team"),
                ("Contact", "levi.beak@parksystems.com"),
            ]),
        ]
        
        for section_title, items in sections:
            # 섹션 프레임
            section_frame = ttk.LabelFrame(container, text=section_title, padding="10")
            section_frame.pack(fill=tk.X, pady=(0, 10))
            
            # 그리드 구성
            for i, (key, value) in enumerate(items):
                ttk.Label(section_frame, text=key + ":", style="Header.TLabel").grid(
                    row=i, column=0, sticky="w", padx=(0, 10), pady=2)
                ttk.Label(section_frame, text=value, style="Content.TLabel").grid(
                    row=i, column=1, sticky="w", pady=2)
        
        # 프로그램 설명
        desc_frame = ttk.LabelFrame(container, text="Description", padding="10")
        desc_frame.pack(fill=tk.X, pady=(0, 10))
        
        description = """이 프로그램은 XES 데이터베이스 비교 및 관리를 위한 프로그램입니다.
        
주요 기능:
• 다중 DB 파일 비교 분석
• 차이점 자동 감지 및 하이라이트
• 상세 비교 보고서 생성
• 데이터 시각화 및 통계 분석
• QC 스펙 관리 및 검증(추가 예정)
"""
        
        ttk.Label(desc_frame, text=description, style="Content.TLabel", 
                 wraplength=500, justify="left").pack(anchor="w")
        
        # 리비전 히스토리 데이터
        revisions = [
            {
                "version": "1.0.0",
                "date": "2025-02-04",
                "summary": "초기 버전 출시",
                "details": {
                    "Features": [
                        "다중 XES DB 파일 비교 분석 기능",
                        "자동 차이점 감지 및 하이라이트",
                        "상세 비교 보고서 생성"
                    ],
                    "Improvements": [
                        "데이터 시각화 도구 추가"
                    ],
                    "Bug Fixes": [
                        "파일 로드 시 인코딩 문제 수정",
                        "메모리 사용량 최적화"
                    ]
                }
            }
            # 새로운 버전이 출시될 때마다 여기에 추가
        ]
        
        # 리비전 히스토리를 위한 트리뷰 생성
        revision_frame = ttk.LabelFrame(container, text="Revision History", padding="10")
        revision_frame.pack(fill=tk.X, pady=(0, 10))
        
        revision_tree = ttk.Treeview(revision_frame, height=6)
        revision_tree["columns"] = ("Version", "Date", "Summary")
        revision_tree.heading("#0", text="")
        revision_tree.column("#0", width=0, stretch=False)
        
        for col, width in [("Version", 70), ("Date", 100), ("Summary", 400)]:
            revision_tree.heading(col, text=col)
            revision_tree.column(col, width=width)
        
        # 리비전 데이터 추가
        for rev in revisions:
            revision_tree.insert("", 0, values=(
                rev["version"],
                rev["date"],
                rev["summary"]
            ), tags=("revision",))
        
        # 더블 클릭 이벤트 처리
        def show_revision_details(event):
            item = revision_tree.selection()[0]
            version = revision_tree.item(item)["values"][0]
            
            # 해당 버전의 상세 정보 찾기
            rev_info = next(r for r in revisions if r["version"] == version)
            
            # 상세 정보 창 생성
            detail_window = tk.Toplevel(about_window)
            detail_window.title(f"Version {version} Details")
            detail_window.geometry("500x800")  # About 창과 같은 높이로 설정
            detail_window.transient(about_window)
            detail_window.grab_set()
            
            # About 창 오른쪽에 나란히 표시 (화면 범위 체크 추가)
            about_x = about_window.winfo_x()
            about_y = about_window.winfo_y()
            about_width = about_window.winfo_width()
            
            # 화면 크기 확인
            screen_width = detail_window.winfo_screenwidth()
            
            # 새 창의 x 좌표 계산
            new_x = about_x + about_width + 10
            
            # 화면 밖으로 넘어갈 경우 About 창 왼쪽에 표시
            if new_x + 500 > screen_width:  # 500은 detail_window의 너비
                new_x = about_x - 510  # 왼쪽에 표시 (간격 10픽셀)
            
            detail_window.geometry(f"500x800+{new_x}+{about_y}")
            
            # 스타일 설정
            style = ttk.Style()
            style.configure("Category.TLabel", font=('Helvetica', 11, 'bold'))
            style.configure("Item.TLabel", font=('Helvetica', 10))
            
            # 컨테이너 생성
            detail_container = ttk.Frame(detail_window, padding="20")
            detail_container.pack(fill=tk.BOTH, expand=True)
            
            # 버전 정보 헤더
            ttk.Label(
                detail_container,
                text=f"Version {version} ({rev_info['date']})",
                style="Title.TLabel"
            ).pack(anchor="w", pady=(0, 20))
            
            # 카테고리별 상세 정보 표시
            for category, items in rev_info["details"].items():
                # 카테고리 제목
                ttk.Label(
                    detail_container,
                    text=category,
                    style="Category.TLabel"
                ).pack(anchor="w", pady=(10, 5))
                
                # 항목들
                for item in items:
                    ttk.Label(
                        detail_container,
                        text=f"• {item}",
                        style="Item.TLabel",
                        wraplength=450
                    ).pack(anchor="w", padx=(20, 0))
            
            # 닫기 버튼
            ttk.Button(
                detail_container,
                text="닫기",
                command=detail_window.destroy
            ).pack(pady=(20, 0))
        
        # 더블 클릭 이벤트 바인딩
        revision_tree.bind("<Double-1>", show_revision_details)
        
        # 스크롤바 추가
        scrollbar = ttk.Scrollbar(revision_frame, orient="vertical", command=revision_tree.yview)
        revision_tree.configure(yscrollcommand=scrollbar.set)
        
        # 레이아웃
        revision_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # 닫기 버튼
        ttk.Button(container, text="닫기", command=about_window.destroy).pack(pady=(0, 10))

    def show_user_guide(self, event=None):
        print("사용 설명서가 호출되었습니다. (F1 키 또는 메뉴 선택)")
        guide_window = tk.Toplevel(self.window)
        guide_window.title("DB 관리 도구 사용 설명서")
        guide_window.geometry("800x600")
        guide_window.resizable(True, True)  # 창 크기 조절 가능
        
        # 부모 창 중앙에 위치
        x = self.window.winfo_x() + (self.window.winfo_width() // 2) - (800 // 2)
        y = self.window.winfo_y() + (self.window.winfo_height() // 2) - (600 // 2)
        guide_window.geometry(f"800x600+{x}+{y}")
        
        # 스타일 설정
        style = ttk.Style()
        style.configure("Title.TLabel", font=('Helvetica', 16, 'bold'))
        style.configure("Heading.TLabel", font=('Helvetica', 12, 'bold'))
        style.configure("Content.TLabel", font=('Helvetica', 10))
        
        # 메인 프레임과 캔버스, 스크롤바 설정
        main_frame = ttk.Frame(guide_window)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        canvas = tk.Canvas(main_frame)
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # 내용 구성
        sections = [
            {
                "title": "시작하기",
                "content": [
                    "1. 프로그램 실행 후 '파일' 메뉴에서 '폴더 열기' 선택",
                    "2. DB Editor에서 Export한 .txt 파일이 있는 폴더 선택",
                    "3. 최대 6개의 DB 파일들을 선택하여 비교 분석 실행"
                ]
            },
            {
                "title": "주요 기능",
                "content": [
                    "• DB 파일 비교 분석",
                    "  - 여러 DB 파일의 내용을 자동으로 비교",
                    "  - 차이점 자동 감지 및 하이라이트",
                    "  - 상세 비교 결과 제공",
                    "",
                    "• QC 검수 기능 (추가 예정)",
                    "  - 설정된 기준에 따른 자동 검증",
                    "  - 오류 항목 자동 감지",
                    "  - 검수 결과 리포트 생성"
                ]
            },
            {
                "title": "단축키",
                "content": [
                    "• Ctrl + O : 폴더 열기",
                    "• Ctrl + Q : 프로그램 종료",
                    "• F1 : 도움말 열기"
                ]
            },
            {
                "title": "자주 묻는 질문",
                "content": [
                    "Q: 지원하는 파일 형식은 무엇인가요?",
                    "A: DB Editor에서 Export한 .txt 파일을 지원합니다.",
                    "",
                    "Q: 한 번에 몇 개의 파일을 비교할 수 있나요?",
                    "A: 최대 6개의 파일을 동시에 비교할 수 있습니다.",
                    ""
                ]
            }
        ]
        
        # 제목
        ttk.Label(
            scrollable_frame,
            text="DB 관리 프로그램 사용 설명서",
            style="Title.TLabel"
        ).pack(pady=(0, 20))
        
        # 섹션별 내용 추가
        for section in sections:
            # 섹션 제목
            ttk.Label(
                scrollable_frame,
                text=section["title"],
                style="Heading.TLabel"
            ).pack(anchor="w", pady=(15, 5))
            
            # 섹션 내용
            for line in section["content"]:
                ttk.Label(
                    scrollable_frame,
                    text=line,
                    style="Content.TLabel",
                    wraplength=700,
                    justify="left"
                ).pack(anchor="w", padx=(20, 0))
        
        # 레이아웃 설정
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

    def update_log(self, message):
        if hasattr(self, 'log_text'):
            self.log_text.insert("end", message + "\n")
            self.log_text.see("end")

class LoadingDialog:
    def __init__(self, parent):
        self.top = tk.Toplevel(parent)
        self.top.title("로딩 중...")
        
        # 부모 창 중앙에 위치
        window_width = 300
        window_height = 100
        screen_width = parent.winfo_screenwidth()
        screen_height = parent.winfo_screenheight()
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.top.geometry(f'{window_width}x{window_height}+{x}+{y}')
        
        # 항상 최상위에 표시
        self.top.transient(parent)
        self.top.grab_set()
        
        # 진행 상태 표시
        self.progress_var = tk.DoubleVar()
        self.progress = ttk.Progressbar(
            self.top, 
            variable=self.progress_var,
            maximum=100,
            mode='determinate',
            length=200
        )
        self.progress.pack(pady=10)
        
        # 현재 작업 설명
        self.status_label = ttk.Label(self.top, text="파일 로딩 중...")
        self.status_label.pack(pady=5)
        
        # 진행률 텍스트
        self.percentage_label = ttk.Label(self.top, text="0%")
        self.percentage_label.pack(pady=5)
        
        # 창 닫기 버튼 비활성화
        self.top.protocol("WM_DELETE_WINDOW", lambda: None)
        
    def update_progress(self, value, status_text=None):
        self.progress_var.set(value)
        self.percentage_label.config(text=f"{int(value)}%")
        if status_text:
            self.status_label.config(text=status_text)
        self.top.update()
    
    def close(self):
        self.top.grab_release()
        self.top.destroy()

def main():
    app = DBManager()
    app.window.mainloop()

if __name__ == "__main__":
    main() 